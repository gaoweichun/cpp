## 引用与指针
 在底层，引用变量由指针按照常量的方式实现。与某对象绑定后不可更改。
* 引用与指针常量的关系
    1.  在内存中都占用4个字节。存放的都是被引用对象的地址，必须在定义的同时进行初始化。(__是否必须初始化，是否占用内存__)
    2.  指针常量本身允许寻址（以p为例），即&p返回指针常量本身的地址，指向对象用*p表示；引用变量本身（以r为例）不允许寻址，&r返回的是被引用对象的地址，而不是变量r的地址（r的地址由编译器掌握，程序员无法对它进行存取），被引用对象直接用r表示。（__是否可寻址__）
    3.  引用绑定之后不可变（__是否可变__）
    4.  引用只能一级，指针可以多级（__是否能为多级__）


## static

### 一、 static 修饰基本数据类型
参考： https://www.cnblogs.com/LUO77/p/5771237.html
1.  修饰局部变量
* 内存中的位置： 静态存储区
* 初始化： 局部的静态变量只能被初始化一次，且C中不可以用变量对其初始化，而C++可以用变量对其初始化。（c中对静态局部变量的初始化发生在代码执行前，编译阶段分配好内存后，就会对其进行初始化，所以C中无法使用变量对其进行初始化。而在C++中，初始化是在运行到相关代码时，主要原因是因为C++引入对象，要进行初始化需要执行响应构造函数）
* 作用域： 作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。


注：  static用来修饰局部变量的时候，它就改变了局部变量的*存储位置*（从原来的栈中存放改为静态存储区）及其*生命周期*，但未改变其*作用域*。

2.  修饰全局变量
 * 内存中位置：静态存储区
 * 初始化：未经初始化的全局静态变量会被程序自动初始化为0
 * 作用域： 全局静态变量在它的声明文件之外是不可见的。准确的讲是从定义之处到文件结尾

 注： static修饰全局变量，未改变其存储位置及生命周期，而是改变了其作用域。使当前文件外的源文件无法访问。

### 二、 static 应用到函数中
修饰函数，使得函数只能在当前文件中使用。
### 三、 在类中的使用
##### 静态成员变量
static 声明的成员变量在类中只占一份内存，为所有对象共同拥有和维护。
1. 静态成员变量在类内进行声明，在类外进行定义和初始化。在类外进行初始化的时候，不能出现static 关键字和 private/protected/public访问规则。（__声明与初始化__）
2. 静态成员变量相当于类域中的全局变量，被类的所有对象共享，包括派生类。
3. 静态成员变量可以作为成员函数形参的默认值，普通成员变量不可以。不过也可以用const修饰static数据成员在类内初始化。
```C++
class base{ 
public : 
    static int _staticVar; 
    int _var; 
    void foo1(int i=_staticVar);//正确,_staticVar为静态数据成员 
    void foo2(int i=_var);//错误,_var为普通数据成员 
};
```
4. 静态数据成员的类型可以是所属类的类型，而普通数据成员不可以。普通数据成员只能声明成类的指针或引用。
```C++
class base{ 
public : 
    static base _object1;//正确，静态数据成员 
    base _object2;//错误 
    base *pObject;//正确，指针 
    base &mObject;//正确，引用 
};
```

##### static 静态成员函数：
普通成员函数中有隐藏的this指针。静态函数没有this指针。可以通过对象或类名调用。
1. 静态成员函数不能调用非静态成员变量或非静态成员函数。
2. 静态成员函数不能声明为虚函数、const、volate
3. 所以对象共享静态函数，不含this指针
4. 静态成员可以独立访问，无需创建任何对象实例就可以通过静态函数访问。
5. 当static 成员函数在类外定义时不需要static修饰。
6. 不可以同时使用const和static修饰成员函数
    C++编译器在实现const的成员函数时为了确保函数不能修改类的实例状态，会在函数中添加一个隐式的参数const this* .当一个成员函数为static时，是没有this指针的。

#### 在普通函数中
##### 静态变量与静态函数
1. static作用与局部变量时，改变了局部变量的生存周期。局部变量保存于栈上。栈上的内容只在函数的范围内存在，当函数运行结束后，这些内容也会被销毁。自动全局变量和static变量（包括static全局和局部变量）保存于静态区，静态区的内容在程序整个生命周期都存在，由编译器分配。
2. static 作于用全局变量和函数，使得全局变量和函数只在本文件有效。

## const
参考：https://blog.csdn.net/Eric_Jo/article/details/4138548?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param
### 一、 const 修饰基本数据类型

### 二、 const 应用到函数中
1. const 修饰函数参数
2. const 修饰函数返回值
通常用于操作符重载。（防止计算结果被赋值。
### 三、 类相关const
1. const 修饰成员变量
const修饰类的变量，表示成员常量。不能被修改，**同时只能在初始化列表中赋值。（如果不在初始化列表中赋值，则会默认初始化再赋值，违背const原则）**
2. 修饰成员函数
    * const 修饰类的成员函数，则该成员函数不能修改类中的任何成员变量。一般写在函数的最后来修饰。
    ```c++
    class A
    {
        ...
        void function() const;//常成员函数，不能改变对象的成员变量。
                            //也不能调用非常成员函数；
    }
    ```
    *  对于const类对象/指针/引用，只能调用const成员函数，
3. const 修饰类对象/对象指针/对象引用
    * const修饰类对象表示该对象为常量对象。不能修改其成员对象。对于对象指针和对象引用也一样
    * const修饰的对象。不能调用该对象的非const成员函数。因为非const成员函数可能修改成员变量。
    * 当调用常对象的默认初始化列表时。对象必须存在默认构造函数。
    
## new与delete
参考：https://www.cnblogs.com/qg-whz/p/5140930.html
* **属性**
 malloc/free 是库函数，需要头文件的支持；new/delete是关键字，需要编译器支持。
* **申请内存的位置**
 new操作符从自由存储区（free store）上为对象分配内存，而malloc函数从堆上动态分配内存。
* **是否需要指定内存大小** 
使用new操作符申请内存时无需指定内存大小，编译器会根据类型信息自行计算，而malloc需要显示指定出所需内存大小。
```cpp
class A{...}
A* ptr = new A;
A* ptr == (A *)malloc(sizeof(A))；//需要显示指定内存所需大小
```
* **返回类型安全性**
new操作内存分配成功，返回的是对象类型的指针，类型与对象匹配，无须进行类型转换，故new是符合类型安全的操作符。而malloc内存分配返回的是void *，需要通过亲啊复制类型转换将void* 指针转换成我们需要的类型/
* **内存分配失败时的返回值**
new 内存分配失败时，会抛出bac_alloc异常，不会返回NULL；malloc分配内存失败时会返回NULL。
* **是否调用构造函数**
参考：https://blog.csdn.net/fengbingchun/article/details/78991749
使用new操作符分配对象有三个过程：
    * 调用operate new函数（对于数组则是operate new[]）的标准库函数。该函数分配一个原始的、足够大的、未命名的内存空间以便存储特定内存对象（或者对象数组)。第二步编译器运行响应构造函数以构造这些对象，并为其传入初值。第三步，对象被分配了空间并构造完成，返回一个指向该对象的指针。


当调用delete表达式删除一个动态分配的内存时。
```cpp
delete sp;
delete[] arr;
```
实际上执行两步：
    * 第一步：对sp所指的对象或者arr所指的数组中的元素执行对应的析构函数。第二步：编译其调用名为 operator delete(或者operate delete[])的标准库函数释放空间。

## 多态
多态（polymorphism）可分为静态多态与动态多态。
** Run time ** 编译器编译程序运行时可能用到的所有代码，并在运行时选择正确的代码。
* ** 虚函数virtual **
 声明基类的指针，利用该指针指向一个子类对象，调用相应的函数。
 * ** 纯虚函数 **
    * 在基类中声明的虚函数，在基类中没有定义。但要求派生类实现自己定义的实现方法。
    * 包含纯虚函数的类称为抽象类。
    * 如果父类或者祖先类中函数func()为虚函数，则其子类及其后代类中函数func（）是否加virtual都将是虚函数。为提高程序可读性，建议后代虚函数中都加上vitual 关键字。


* 函数重写使得虚函数不能静态编译
* 虚函数的分配在运行时
* 对每一个继承或者定义了虚函数的类，编译器都会生产虚表
* 虚指针指向虚表
* 将基类的析构函数声明为虚函数
## const与 define
1. define 定义的变量在内存中有若干分备份。 const 定定义的变量只有一份